<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Âª∂Èôµ‰∏ñÂÆ∂‚Äî‚ÄîÂáâÊ∞¥Âü†Âê¥Ê∞èÂÆ∂Ë∞±</title>
  <meta name="description" content="ÂáâÊ∞¥Âü†Âê¥Ê∞èÂÆ∂ÊóèÂÆ∂Ë∞±‰∫íÂä®ÂèØËßÜÂåñ">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box
    }

    body {
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d11 100%);
      color: #c0c0c0;
      font-family: 'Noto Serif SC', serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      user-select: none
    }

    #tree-canvas {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0
    }

    svg {
      width: 100%;
      height: 100%
    }

    .node-circle {
      cursor: pointer;
      transition: filter .3s
    }

    .node-circle:hover {
      filter: drop-shadow(0 0 8px rgba(212, 175, 55, .6))
    }

    .node-label {
      fill: #D4AF37;
      font-family: 'Noto Serif SC', serif;
      font-size: 13px;
      cursor: pointer;
      font-weight: 600
    }

    .node-gen-label {
      fill: #909090;
      font-family: 'Noto Serif SC', serif;
      font-size: 10px
    }

    .link-line {
      fill: none;
      stroke: #505058;
      stroke-width: 1.5;
      opacity: .6
    }

    .search-highlight .node-label {
      fill: #FF8C00 !important
    }

    .search-highlight circle {
      fill: #FF8C00 !important;
      stroke: #FF8C00 !important
    }

    /* Control Panel */
    #control-panel {
      position: fixed;
      left: 16px;
      bottom: 16px;
      width: 220px;
      background: rgba(20, 20, 28, .92);
      border: 1px solid rgba(212, 175, 55, .25);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 24px rgba(0, 0, 0, .5)
    }

    #control-panel h1 {
      color: #D4AF37;
      font-size: 20px;
      line-height: 1.3;
      margin-bottom: 2px;
      text-shadow: 0 0 12px rgba(212, 175, 55, .3)
    }

    #control-panel .stats {
      color: #808080;
      font-size: 11px;
      margin-bottom: 10px
    }

    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 10px
    }

    .ctrl-btn {
      background: rgba(212, 175, 55, .1);
      border: 1px solid rgba(212, 175, 55, .3);
      color: #D4AF37;
      padding: 7px 0;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Noto Serif SC', serif;
      font-size: 12px;
      transition: all .2s
    }

    .ctrl-btn:hover {
      background: rgba(212, 175, 55, .2);
      border-color: rgba(212, 175, 55, .5)
    }

    .ctrl-btn:active {
      transform: scale(.96)
    }

    /* Minimap */
    #minimap-container {
      width: 100%;
      height: 90px;
      background: rgba(0, 0, 0, .4);
      border: 1px solid rgba(100, 100, 100, .3);
      border-radius: 6px;
      margin-bottom: 10px;
      position: relative;
      overflow: hidden;
      cursor: crosshair
    }

    #minimap-canvas {
      width: 100%;
      height: 100%
    }

    #minimap-viewport {
      position: absolute;
      border: 1.5px solid #FF8C00;
      background: rgba(255, 140, 0, .08);
      pointer-events: none;
      border-radius: 2px
    }

    /* Search */
    #search-wrap {
      position: relative
    }

    #search-input {
      width: 100%;
      background: rgba(30, 30, 40, .8);
      border: 1px solid rgba(100, 100, 100, .3);
      color: #c0c0c0;
      padding: 7px 10px 7px 30px;
      border-radius: 6px;
      font-size: 12px;
      outline: none;
      font-family: 'Noto Serif SC', serif
    }

    #search-input:focus {
      border-color: rgba(212, 175, 55, .4)
    }

    #search-icon {
      position: absolute;
      left: 9px;
      top: 50%;
      transform: translateY(-50%);
      color: #606060;
      font-size: 13px;
      pointer-events: none
    }

    #search-results {
      position: absolute;
      bottom: calc(100% + 4px);
      left: 0;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(20, 20, 28, .95);
      border: 1px solid rgba(100, 100, 100, .3);
      border-radius: 6px;
      display: none;
      z-index: 200
    }

    #search-results::-webkit-scrollbar {
      width: 4px
    }

    #search-results::-webkit-scrollbar-thumb {
      background: rgba(212, 175, 55, .3);
      border-radius: 2px
    }

    .search-item {
      padding: 7px 10px;
      cursor: pointer;
      font-size: 12px;
      color: #b0b0b0;
      border-bottom: 1px solid rgba(60, 60, 60, .3);
      transition: background .15s
    }

    .search-item:hover {
      background: rgba(212, 175, 55, .1);
      color: #D4AF37
    }

    .search-item .gen {
      color: #707070;
      font-size: 10px;
      margin-left: 6px
    }

    /* Info Panel */
    #info-panel {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 280px;
      max-height: 400px;
      background: rgba(20, 20, 28, .94);
      border: 1px solid rgba(212, 175, 55, .2);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      backdrop-filter: blur(12px);
      display: none;
      box-shadow: 0 4px 24px rgba(0, 0, 0, .5);
      overflow-y: auto
    }

    #info-panel::-webkit-scrollbar {
      width: 4px
    }

    #info-panel::-webkit-scrollbar-thumb {
      background: rgba(212, 175, 55, .3);
      border-radius: 2px
    }

    #info-name {
      color: #D4AF37;
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 4px;
      line-height: 1.4
    }

    #info-gen {
      color: #909090;
      font-size: 12px;
      margin-bottom: 8px
    }

    #info-descendants {
      color: #707070;
      font-size: 11px;
      margin-bottom: 8px
    }

    #info-desc {
      color: #a0a0a0;
      font-size: 12px;
      line-height: 1.6;
      white-space: pre-wrap;
      margin-bottom: 8px;
      min-height: 20px;
      border-top: 1px solid rgba(80, 80, 80, .3);
      padding-top: 8px
    }

    #info-edit-btn {
      background: rgba(212, 175, 55, .12);
      border: 1px solid rgba(212, 175, 55, .3);
      color: #D4AF37;
      padding: 5px 14px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Noto Serif SC', serif;
      font-size: 11px;
      transition: all .2s
    }

    #info-edit-btn:hover {
      background: rgba(212, 175, 55, .22)
    }

    #info-textarea {
      width: 100%;
      min-height: 80px;
      background: rgba(30, 30, 40, .8);
      border: 1px solid rgba(100, 100, 100, .4);
      color: #c0c0c0;
      padding: 8px;
      border-radius: 5px;
      font-size: 12px;
      font-family: 'Noto Serif SC', serif;
      outline: none;
      resize: vertical;
      margin-top: 6px;
      display: none;
      line-height: 1.6
    }

    #info-save-btn {
      background: rgba(212, 175, 55, .15);
      border: 1px solid rgba(212, 175, 55, .35);
      color: #D4AF37;
      padding: 5px 14px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Noto Serif SC', serif;
      font-size: 11px;
      margin-top: 6px;
      display: none;
      transition: all .2s
    }

    #info-save-btn:hover {
      background: rgba(212, 175, 55, .25)
    }

    #info-close {
      position: absolute;
      top: 10px;
      right: 12px;
      color: #606060;
      cursor: pointer;
      font-size: 16px;
      line-height: 1
    }

    #info-close:hover {
      color: #D4AF37
    }

    /* Password Overlay */
    #pwd-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 15, .97);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }

    #pwd-overlay h2 {
      color: #D4AF37;
      font-size: 22px;
      margin-bottom: 20px;
      text-shadow: 0 0 12px rgba(212, 175, 55, .3);
    }

    #pwd-overlay input {
      width: 260px;
      padding: 10px 14px;
      background: rgba(30, 30, 40, .8);
      border: 1px solid rgba(212, 175, 55, .3);
      color: #c0c0c0;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      font-family: 'Noto Serif SC', serif;
      text-align: center;
    }

    #pwd-overlay input:focus {
      border-color: rgba(212, 175, 55, .6);
    }

    #pwd-overlay .pwd-btn {
      margin-top: 14px;
      padding: 8px 40px;
      background: rgba(212, 175, 55, .15);
      border: 1px solid rgba(212, 175, 55, .4);
      color: #D4AF37;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-family: 'Noto Serif SC', serif;
    }

    #pwd-overlay .pwd-btn:hover {
      background: rgba(212, 175, 55, .25);
    }

    #pwd-overlay .pwd-error {
      color: #ff6b6b;
      font-size: 12px;
      margin-top: 10px;
      min-height: 18px;
    }

    /* Update Log Link */
    .ctrl-links {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 8px;
    }

    .ctrl-links a {
      color: #808080;
      font-size: 11px;
      cursor: pointer;
      text-decoration: underline;
      transition: color .2s;
    }

    .ctrl-links a:hover {
      color: #D4AF37;
    }

    /* Update Log Panel */
    #log-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, .6);
      z-index: 8000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    #log-panel {
      width: 60%;
      height: 90%;
      background: rgba(20, 20, 28, .96);
      border: 1px solid rgba(212, 175, 55, .25);
      border-radius: 14px;
      padding: 24px;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 40px rgba(0, 0, 0, .6);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #log-panel h2 {
      color: #D4AF37;
      font-size: 18px;
      margin: 0 0 16px 0;
      flex-shrink: 0;
    }

    #log-panel .log-close {
      position: absolute;
      top: 16px;
      right: 20px;
      color: #606060;
      cursor: pointer;
      font-size: 18px;
    }

    #log-panel .log-close:hover {
      color: #D4AF37;
    }

    #log-list {
      flex: 1;
      overflow-y: auto;
      padding-right: 8px;
    }

    #log-list::-webkit-scrollbar {
      width: 4px;
    }

    #log-list::-webkit-scrollbar-thumb {
      background: rgba(212, 175, 55, .3);
      border-radius: 2px;
    }

    .log-entry {
      border-bottom: 1px solid rgba(60, 60, 60, .3);
      padding: 12px 0;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #808080;
      font-size: 11px;
      margin-bottom: 4px;
    }

    .log-person {
      color: #D4AF37;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .log-content {
      color: #b0b0b0;
      font-size: 12px;
      line-height: 1.5;
      white-space: pre-wrap;
    }

    .log-empty {
      color: #606060;
      font-size: 13px;
      text-align: center;
      padding: 40px 0;
    }

    /* Node Hover Tooltip */
    #node-tooltip {
      position: fixed;
      display: none;
      background: rgba(20, 20, 28, .95);
      border: 1px solid rgba(212, 175, 55, .35);
      border-radius: 8px;
      padding: 6px;
      z-index: 500;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, .5);
      gap: 4px;
    }

    .tooltip-btn {
      display: block;
      width: 100%;
      background: rgba(212, 175, 55, .08);
      border: 1px solid rgba(212, 175, 55, .2);
      color: #D4AF37;
      padding: 5px 14px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Noto Serif SC', serif;
      font-size: 11px;
      white-space: nowrap;
      transition: all .15s;
      margin-bottom: 3px;
    }

    .tooltip-btn:last-child {
      margin-bottom: 0;
    }

    .tooltip-btn:hover {
      background: rgba(212, 175, 55, .2);
      border-color: rgba(212, 175, 55, .5);
    }

    .tooltip-btn.danger {
      color: #ff6b6b;
      border-color: rgba(255, 107, 107, .2);
      background: rgba(255, 107, 107, .06);
    }

    .tooltip-btn.danger:hover {
      background: rgba(255, 107, 107, .15);
      border-color: rgba(255, 107, 107, .4);
    }

    /* Add Node Dialog */
    #add-node-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, .6);
      z-index: 8500;
      display: none;
      align-items: center;
      justify-content: center;
    }

    #add-node-dialog {
      width: 360px;
      background: rgba(20, 20, 28, .96);
      border: 1px solid rgba(212, 175, 55, .25);
      border-radius: 14px;
      padding: 24px;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 40px rgba(0, 0, 0, .6);
      position: relative;
    }

    #add-node-dialog h3 {
      color: #D4AF37;
      font-size: 16px;
      margin: 0 0 16px 0;
    }

    #add-node-dialog label {
      color: #a0a0a0;
      font-size: 12px;
      display: block;
      margin-bottom: 4px;
    }

    #add-node-dialog input,
    #add-node-dialog textarea {
      width: 100%;
      background: rgba(30, 30, 40, .8);
      border: 1px solid rgba(100, 100, 100, .3);
      color: #c0c0c0;
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      outline: none;
      font-family: 'Noto Serif SC', serif;
      margin-bottom: 12px;
      box-sizing: border-box;
    }

    #add-node-dialog textarea {
      height: 60px;
      resize: vertical;
    }

    #add-node-dialog input:focus,
    #add-node-dialog textarea:focus {
      border-color: rgba(212, 175, 55, .4);
    }

    .dialog-btns {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .dialog-btn {
      padding: 7px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Noto Serif SC', serif;
      border: 1px solid;
    }

    .dialog-btn.primary {
      background: rgba(212, 175, 55, .15);
      border-color: rgba(212, 175, 55, .4);
      color: #D4AF37;
    }

    .dialog-btn.primary:hover {
      background: rgba(212, 175, 55, .25);
    }

    .dialog-btn.cancel {
      background: transparent;
      border-color: rgba(100, 100, 100, .3);
      color: #808080;
    }

    .dialog-btn.cancel:hover {
      border-color: rgba(100, 100, 100, .5);
      color: #a0a0a0;
    }
  </style>
</head>

<body>
  <div id="tree-canvas"></div>

  <!-- Control Panel -->
  <div id="control-panel">
    <h1>Âª∂Èôµ‰∏ñÂÆ∂<br>ÂáâÊ∞¥Âü†Âê¥Ê∞èÂÆ∂Ë∞±</h1>
    <div class="stats" id="stats-line">Âä†ËΩΩ‰∏≠‚Ä¶</div>
    <div class="btn-grid">
      <button class="ctrl-btn" id="btn-expand" title="Â±ïÂºÄÂÖ®ÈÉ®">Â±ïÂºÄÂÖ®ÈÉ®</button>
      <button class="ctrl-btn" id="btn-collapse" title="Êî∂Ëµ∑ÂÖ®ÈÉ®">Êî∂Ëµ∑ÂÖ®ÈÉ®</button>
      <button class="ctrl-btn" id="btn-zoomin" title="ÊîæÂ§ß">Êîæ Â§ß</button>
      <button class="ctrl-btn" id="btn-zoomout" title="Áº©Â∞è">Áº© Â∞è</button>
    </div>
    <div id="minimap-container">
      <canvas id="minimap-canvas"></canvas>
      <div id="minimap-viewport"></div>
    </div>
    <div id="search-wrap">
      <span id="search-icon">üîç</span>
      <input id="search-input" type="text" placeholder="ÊêúÁ¥¢‰∫∫Âêç‚Ä¶" autocomplete="off">
      <div id="search-results"></div>
    </div>
    <div class="ctrl-links">
      <a id="update-log-link">üìã Êõ¥Êñ∞ËÆ∞ÂΩï</a>
      <a id="export-link">üíæ ÂØºÂá∫Êï∞ÊçÆ</a>
    </div>
  </div>

  <!-- Password Overlay -->
  <div id="pwd-overlay">
    <h2>Âª∂Èôµ‰∏ñÂÆ∂ ¬∑ ÂáâÊ∞¥Âü†Âê¥Ê∞èÂÆ∂Ë∞±</h2>
    <input id="pwd-input" type="password" placeholder="ËØ∑ËæìÂÖ•ËÆøÈóÆÂØÜÁ†Å">
    <button class="pwd-btn" id="pwd-btn">Ëøõ ÂÖ•</button>
    <div class="pwd-error" id="pwd-error"></div>
  </div>

  <!-- Update Log Panel -->
  <div id="log-overlay">
    <div id="log-panel" style="position:relative">
      <span class="log-close" id="log-close">‚úï</span>
      <h2>üìã Êõ¥Êñ∞ËÆ∞ÂΩï</h2>
      <div id="log-list"></div>
    </div>
  </div>

  <!-- Node Hover Tooltip -->
  <div id="node-tooltip">
    <button class="tooltip-btn" id="tt-add">Ôºã Ê∑ªÂä†ËäÇÁÇπ</button>
    <button class="tooltip-btn danger" id="tt-delete">‚úï Âà†Èô§ËäÇÁÇπ</button>
  </div>

  <!-- Add Node Dialog -->
  <div id="add-node-overlay">
    <div id="add-node-dialog">
      <h3 id="add-dialog-title">Ê∑ªÂä†Â≠êËäÇÁÇπ</h3>
      <label>ÂßìÂêç</label>
      <input id="add-name" type="text" placeholder="Â¶ÇÔºöÂê¥ÊüêÊüêÔºåÂ¶ªÊùéÊ∞è">
      <label>‰∏ñ‰ª£</label>
      <input id="add-gen" type="text" placeholder="Â¶ÇÔºö8‰∏ñÔºà‰øÆÔºâ">
      <label>Â§áÊ≥®</label>
      <textarea id="add-note" placeholder="ÂèØÈÄâÂ§áÊ≥®‰ø°ÊÅØ‚Ä¶"></textarea>
      <div class="dialog-btns">
        <button class="dialog-btn cancel" id="add-cancel">ÂèñÊ∂à</button>
        <button class="dialog-btn primary" id="add-confirm">Á°ÆËÆ§Ê∑ªÂä†</button>
      </div>
    </div>
  </div>

  <!-- Info Panel -->
  <div id="info-panel">
    <span id="info-close">‚úï</span>
    <div id="info-name"></div>
    <div id="info-gen"></div>
    <div id="info-descendants"></div>
    <div id="info-desc"></div>
    <button id="info-edit-btn">ÁºñËæë</button>
    <textarea id="info-textarea" placeholder="Ê∑ªÂä†Â§áÊ≥®‰ø°ÊÅØ‚Ä¶"></textarea>
    <button id="info-save-btn">‰øùÂ≠ò</button>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // ====== Password Gate ======
    (function () {
      const overlay = document.getElementById('pwd-overlay');
      const input = document.getElementById('pwd-input');
      const btn = document.getElementById('pwd-btn');
      const err = document.getElementById('pwd-error');
      function tryLogin() {
        if (input.value === 'wujiachaguan') {
          overlay.style.display = 'none';
        } else {
          err.textContent = 'ÂØÜÁ†ÅÈîôËØØÔºåËØ∑ÈáçËØï';
          input.value = '';
          input.focus();
        }
      }
      btn.addEventListener('click', tryLogin);
      input.addEventListener('keydown', e => { if (e.key === 'Enter') tryLogin(); });
      input.focus();
    })();

    // ====== Update Log ======
    function getEditLog() {
      try { return JSON.parse(localStorage.getItem('ft_edit_log') || '[]'); } catch (e) { return []; }
    }
    function addEditLog(personName, personId, content) {
      const log = getEditLog();
      log.unshift({
        time: new Date().toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }),
        person: personName,
        personId: personId,
        content: content
      });
      localStorage.setItem('ft_edit_log', JSON.stringify(log));
    }
    function showEditLog() {
      const overlay = document.getElementById('log-overlay');
      const list = document.getElementById('log-list');
      const log = getEditLog();
      if (log.length === 0) {
        list.innerHTML = '<div class="log-empty">ÊöÇÊó†Êõ¥Êñ∞ËÆ∞ÂΩï</div>';
      } else {
        list.innerHTML = log.map(entry =>
          '<div class="log-entry">' +
          '<div class="log-time">' + entry.time + '</div>' +
          '<div class="log-person">üë§ ' + entry.person + '</div>' +
          '<div class="log-content">' + (entry.content || '(Ê∏ÖÁ©∫Â§áÊ≥®)').replace(/</g, '&lt;') + '</div>' +
          '</div>'
        ).join('');
      }
      overlay.style.display = 'flex';
    }
    document.getElementById('update-log-link').addEventListener('click', showEditLog);

    // ====== Export Data (merge edits into JSON data file) ======
    document.getElementById('export-link').addEventListener('click', () => {
      const pwd = prompt('ËØ∑ËæìÂÖ•ÁºñËæëÂØÜÁ†Å‰ª•ÂØºÂá∫Êï∞ÊçÆÔºö');
      if (pwd !== 'Lsb@1775') { alert('ÂØÜÁ†ÅÈîôËØØ'); return; }
      exportDataJSON();
    });

    function exportDataJSON() {
      // Deep clone and merge all edits into the tree data
      function cloneAndMerge(data) {
        const node = {
          name: data.name,
          id: data.id,
          generation: data.generation || '',
          dc: data.dc || 0,
          depth: data.depth || 0
        };
        // Merge localStorage notes
        const savedNote = localStorage.getItem('ft_note_' + (data.id || data.name));
        if (savedNote) node.note = savedNote;
        else if (data.note) node.note = data.note;
        // Recursively clone children
        const kids = data._children_all || data.children || [];
        if (kids.length > 0) {
          node.children = kids.map(c => cloneAndMerge(c));
        } else {
          node.children = [];
        }
        return node;
      }
      const mergedData = cloneAndMerge(DATA);
      // Re-count descendants
      function recount(node) {
        if (!node.children || node.children.length === 0) { node.dc = 0; return 0; }
        let total = node.children.length;
        node.children.forEach(c => { total += recount(c); });
        node.dc = total;
        return total;
      }
      recount(mergedData);
      // Generate filename with date
      const now = new Date();
      const ymd = now.getFullYear() +
        String(now.getMonth() + 1).padStart(2, '0') +
        String(now.getDate()).padStart(2, '0');
      const filename = 'Âª∂Èôµ‰∏ñÂÆ∂‚Äî‚ÄîÂáâÊ∞¥Âü†Âê¥Ê∞èÂÆ∂Ë∞±-db_' + ymd + '.json';
      // Download JSON
      const json = JSON.stringify(mergedData, null, 2);
      const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      alert('‚úÖ Â∑≤ÂØºÂá∫: ' + filename + '\n\nÊâÄÊúâÁºñËæëËÆ∞ÂΩïÂ∑≤ÂêàÂπ∂Âà∞Êï∞ÊçÆÊñá‰ª∂‰∏≠„ÄÇ\nËØ∑Â∞ÜÊ≠§Êñá‰ª∂ÊõøÊç¢ÊúçÂä°Âô®‰∏äÁöÑÊóßÊï∞ÊçÆÊñá‰ª∂„ÄÇ');
    }
    document.getElementById('log-close').addEventListener('click', () => {
      document.getElementById('log-overlay').style.display = 'none';
    });
    document.getElementById('log-overlay').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) e.currentTarget.style.display = 'none';
    });

    // ====== Data File Configuration ======
    const DATA_FILE = 'family_data.json';

    // Load data from external file
    fetch(DATA_FILE)
      .then(r => r.json())
      .then(DATA => initApp(DATA))
      .catch(e => {
        console.error('Failed to load ' + DATA_FILE + ':', e);
        document.getElementById('stats-line').textContent = 'Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Á°Æ‰øù ' + DATA_FILE + ' Âú®Âêå‰∏ÄÁõÆÂΩï';
      });

    function initApp(DATA) {
      // ====== Flatten & Statistics ======
      const allNodes = [];
      const genSet = new Set();
      function walk(node) {
        allNodes.push(node);
        if (node.generation) genSet.add(node.generation);
        if (node.children) node.children.forEach(walk);
      }
      walk(DATA);
      const totalPersons = allNodes.length;
      const totalGens = genSet.size;
      document.getElementById('stats-line').textContent = `ÂÖ± ${totalPersons} ‰∫∫Ôºå${totalGens} ‰ª£`;

      // ====== D3 Setup ======
      const container = document.getElementById('tree-canvas');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const svg = d3.select('#tree-canvas').append('svg')
        .attr('width', width).attr('height', height);

      const defs = svg.append('defs');
      // Glow filter
      const glowFilter = defs.append('filter').attr('id', 'glow');
      glowFilter.append('feGaussianBlur').attr('stdDeviation', '3').attr('result', 'blur');
      glowFilter.append('feMerge').selectAll('feMergeNode')
        .data(['blur', 'SourceGraphic']).enter()
        .append('feMergeNode').attr('in', d => d);

      const g = svg.append('g').attr('class', 'tree-group');

      const zoom = d3.zoom()
        .scaleExtent([0.05, 3])
        .on('zoom', e => {
          g.attr('transform', e.transform);
          updateMinimap();
        });
      svg.call(zoom);

      // ====== Tree Hierarchy ======
      const root = d3.hierarchy(DATA, d => d._children_visible);
      // Initialize: collapse all except root
      function initCollapse(node) {
        if (node.data.children && node.data.children.length > 0) {
          node.data._children_all = node.data.children;
          node.data._children_visible = null; // collapsed
          node.data._expanded = false;
        } else {
          node.data._children_all = null;
          node.data._children_visible = null;
          node.data._expanded = false;
        }
        if (node.data.children) {
          // Temporarily make hierarchy to recurse
          const tempChildren = node.data.children.map(c => d3.hierarchy(c));
          tempChildren.forEach(tc => initCollapse(tc));
        }
      }
      function initCollapseData(data) {
        if (data.children && data.children.length > 0) {
          data._children_all = data.children;
          data._children_visible = null;
          data._expanded = false;
          data.children.forEach(initCollapseData);
        } else {
          data._children_all = null;
          data._children_visible = null;
          data._expanded = false;
        }
      }
      initCollapseData(DATA);

      // Layout constants
      const NODE_WIDTH = 90;
      const NODE_H_GAP = 30;
      const ROW_HEIGHT = 120;
      const CIRCLE_R = 7;
      const LEAF_R = 4;

      let currentSelected = null;
      let searchHighlighted = null;

      // ====== Format generation label ======
      function formatGen(gen) {
        if (!gen) return '';
        // e.g. "10‰∏ñÔºàËâØÔºâ" ‚Üí "Á¨¨10‰∏ñÔºàËâØÂ≠óËæàÔºâ"
        // e.g. "Á•ñ5‰∏ñ" ‚Üí "Á•ñÁ¨¨5‰∏ñ"
        // e.g. "ÂáâÊ∞¥Âü†1‰∏ñÔºàÂ§ßÔºâÔºåÁ•ñ11‰∏ñ" ‚Üí keep as-is
        return gen;
      }

      // ====== Compute Tree Layout ======
      function computeLayout() {
        const hierarchy = d3.hierarchy(DATA, d => d._children_visible);
        // Use d3.tree with bottom-up orientation
        // We'll compute positions manually for generation rows
        // Assign each node a generation-based y and left-to-right x

        hierarchy.eachBefore(n => {
          n._totalLeafCount = 0;
        });

        // Count leaf width for spacing
        function countLeaves(node) {
          if (!node.children || node.children.length === 0) {
            node._leafCount = 1;
            return 1;
          }
          let total = 0;
          node.children.forEach(c => { total += countLeaves(c); });
          node._leafCount = total;
          return total;
        }
        countLeaves(hierarchy);

        // Assign x positions based on leaf counts
        function assignX(node, leftEdge) {
          if (!node.children || node.children.length === 0) {
            node._x = leftEdge + (NODE_WIDTH + NODE_H_GAP) / 2;
            return leftEdge + NODE_WIDTH + NODE_H_GAP;
          }
          let currentLeft = leftEdge;
          node.children.forEach(c => {
            currentLeft = assignX(c, currentLeft);
          });
          // Center parent above children
          const firstChild = node.children[0];
          const lastChild = node.children[node.children.length - 1];
          node._x = (firstChild._x + lastChild._x) / 2;
          return currentLeft;
        }
        assignX(hierarchy, 0);

        // Assign y: bottom-up based on depth. Root at bottom (max depth * ROW_HEIGHT)
        const maxDepth = hierarchy.height;
        hierarchy.each(n => {
          n._y = (maxDepth - n.depth) * ROW_HEIGHT;
        });

        return hierarchy;
      }

      // ====== Render ======
      function render(sourceNode) {
        const hierarchy = computeLayout();
        const nodes = hierarchy.descendants();
        const links = hierarchy.links();

        // Determine source position for animation
        const sx = sourceNode ? sourceNode._x : (nodes[0] ? nodes[0]._x : 0);
        const sy = sourceNode ? sourceNode._y : (nodes[0] ? nodes[0]._y : 0);

        // ---- Links ----
        const linkSel = g.selectAll('.link-line').data(links, d => d.target.data.id || d.target.data.name);

        linkSel.exit()
          .transition().duration(400)
          .attr('d', d => {
            return `M${sx},${sy}L${sx},${sy}`;
          })
          .remove();

        const linkEnter = linkSel.enter().append('path')
          .attr('class', 'link-line')
          .attr('d', d => `M${sx},${sy}L${sx},${sy}`);

        linkEnter.merge(linkSel)
          .transition().duration(400)
          .attr('d', d => {
            const parentX = d.source._x;
            const parentY = d.source._y;
            const childX = d.target._x;
            const childY = d.target._y;
            const midY = parentY - (parentY - childY) * 0.4;
            return `M${parentX},${parentY - CIRCLE_R - 2}` +
              `C${parentX},${midY} ${childX},${midY} ${childX},${childY + CIRCLE_R + 14}`;
          });

        // ---- Nodes ----
        const nodeSel = g.selectAll('.node-group').data(nodes, d => d.data.id || d.data.name);

        nodeSel.exit()
          .transition().duration(400)
          .attr('transform', `translate(${sx},${sy})`)
          .style('opacity', 0)
          .remove();

        const nodeEnter = nodeSel.enter().append('g')
          .attr('class', d => {
            let cls = 'node-group';
            if (searchHighlighted && searchHighlighted === d.data.id) cls += ' search-highlight';
            return cls;
          })
          .attr('transform', `translate(${sx},${sy})`)
          .style('opacity', 0)
          .on('mouseenter', function (event, d) {
            showNodeTooltip(event, d, this);
          })
          .on('mouseleave', function (event) {
            hideNodeTooltipDelay();
          });

        // Circle
        nodeEnter.append('circle')
          .attr('class', 'node-circle')
          .attr('cx', 0).attr('cy', 0)
          .attr('r', d => d.data._children_all ? CIRCLE_R : LEAF_R)
          .attr('fill', d => {
            if (searchHighlighted && searchHighlighted === d.data.id) return '#FF8C00';
            if (!d.data._children_all) return 'transparent';
            return d.data._expanded ? 'transparent' : '#D4AF37';
          })
          .attr('stroke', d => {
            if (searchHighlighted && searchHighlighted === d.data.id) return '#FF8C00';
            return '#D4AF37';
          })
          .attr('stroke-width', d => d.data._children_all ? 2 : 1.2)
          .on('click', (event, d) => {
            event.stopPropagation();
            toggleNode(d);
          });

        // Name label (above circle)
        nodeEnter.append('text')
          .attr('class', d => {
            let cls = 'node-label';
            return cls;
          })
          .attr('text-anchor', 'middle')
          .attr('y', d => CIRCLE_R + 16)
          .each(function (d) {
            const text = d3.select(this);
            const name = d.data.name || '';
            // Wrap text to NODE_WIDTH
            wrapText(text, name, NODE_WIDTH + 10);
          })
          .style('fill', d => (searchHighlighted && searchHighlighted === d.data.id) ? '#FF8C00' : '#D4AF37')
          .on('click', (event, d) => {
            event.stopPropagation();
            showInfoPanel(d);
          });

        // Generation label
        nodeEnter.append('text')
          .attr('class', 'node-gen-label')
          .attr('text-anchor', 'middle')
          .attr('y', d => {
            const nameLines = getTextLines(d.data.name || '', NODE_WIDTH + 10);
            return CIRCLE_R + 16 + nameLines.length * 14 + 4;
          })
          .text(d => formatGen(d.data.generation || ''))
          .style('font-size', '10px');

        // Merge
        const nodeUpdate = nodeEnter.merge(nodeSel);

        nodeUpdate
          .attr('class', d => {
            let cls = 'node-group';
            if (searchHighlighted && searchHighlighted === d.data.id) cls += ' search-highlight';
            return cls;
          })
          .transition().duration(400)
          .attr('transform', d => `translate(${d._x},${d._y})`)
          .style('opacity', 1);

        // Update circles
        nodeUpdate.select('circle')
          .transition().duration(300)
          .attr('r', d => d.data._children_all ? CIRCLE_R : LEAF_R)
          .attr('fill', d => {
            if (searchHighlighted && searchHighlighted === d.data.id) return '#FF8C00';
            if (!d.data._children_all) return 'transparent';
            return d.data._expanded ? 'transparent' : '#D4AF37';
          })
          .attr('stroke', d => {
            if (searchHighlighted && searchHighlighted === d.data.id) return '#FF8C00';
            return '#D4AF37';
          });

        // Update label color for search
        nodeUpdate.select('.node-label')
          .style('fill', d => (searchHighlighted && searchHighlighted === d.data.id) ? '#FF8C00' : '#D4AF37');

        setTimeout(updateMinimap, 500);
        return hierarchy;
      }

      // ====== Text wrapping ======
      function getTextLines(text, maxWidth) {
        const chars = text.split('');
        const lines = [];
        let current = '';
        const charsPerLine = Math.floor(maxWidth / 13);
        for (let i = 0; i < chars.length; i++) {
          current += chars[i];
          if (current.length >= charsPerLine) {
            lines.push(current);
            current = '';
          }
        }
        if (current) lines.push(current);
        return lines.length ? lines : [''];
      }

      function wrapText(textEl, text, maxWidth) {
        const lines = getTextLines(text, maxWidth);
        textEl.text(null);
        lines.forEach((line, i) => {
          textEl.append('tspan')
            .attr('x', 0)
            .attr('dy', i === 0 ? '0' : '1.15em')
            .text(line);
        });
      }

      // ====== Toggle expand/collapse ======
      function toggleNode(d) {
        if (!d.data._children_all) {
          showInfoPanel(d);
          return;
        }
        if (d.data._expanded) {
          // Collapse: hide children
          collapseRecursive(d.data);
          d.data._children_visible = null;
          d.data._expanded = false;
        } else {
          // Expand one level
          d.data._children_visible = d.data._children_all;
          d.data._expanded = true;
        }
        const hierarchy = render(d);
        // Center on clicked node
        const targetNode = findNodeInHierarchy(hierarchy, d.data.id || d.data.name);
        if (targetNode) {
          centerOnNode(targetNode._x, targetNode._y);
        }
        showInfoPanel(d);
      }

      function collapseRecursive(data) {
        if (data._children_all) {
          data._children_all.forEach(c => collapseRecursive(c));
        }
        data._children_visible = null;
        data._expanded = false;
      }

      function findNodeInHierarchy(hierarchy, idOrName) {
        let found = null;
        hierarchy.each(n => {
          if ((n.data.id && n.data.id === idOrName) || n.data.name === idOrName) {
            found = n;
          }
        });
        return found;
      }

      // ====== Center view on a position ======
      function centerOnNode(x, y, scale) {
        const s = scale || d3.zoomTransform(svg.node()).k;
        const tx = width / 2 - x * s;
        const ty = height / 2 - y * s;
        svg.transition().duration(600)
          .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(s));
      }

      // ====== Fit all ======
      function fitAll(zoomMultiplier) {
        const hierarchy = computeLayout();
        const nodes = hierarchy.descendants();
        if (nodes.length === 0) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        nodes.forEach(n => {
          if (n._x < minX) minX = n._x;
          if (n._x > maxX) maxX = n._x;
          if (n._y < minY) minY = n._y;
          if (n._y > maxY) maxY = n._y;
        });
        const treeW = maxX - minX + NODE_WIDTH * 2;
        const treeH = maxY - minY + ROW_HEIGHT;
        const scaleX = (width - 80) / treeW;
        const scaleY = (height - 80) / treeH;
        const s = Math.min(scaleX, scaleY, 1.5) * (zoomMultiplier || 1);
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        centerOnNode(cx, cy, s);
      }

      // ====== Expand / Collapse All ======
      function expandAll(data) {
        if (data._children_all) {
          data._children_visible = data._children_all;
          data._expanded = true;
          data._children_all.forEach(expandAll);
        }
      }

      function collapseAll(data) {
        collapseRecursive(data);
      }

      document.getElementById('btn-expand').addEventListener('click', () => {
        expandAll(DATA);
        render(null);
        setTimeout(() => fitAll(20.66), 500); // 9 zoom levels (1.4^9 ‚âà 20.66x)
      });

      document.getElementById('btn-collapse').addEventListener('click', () => {
        collapseAll(DATA);
        render(null);
        setTimeout(fitAll, 500);
      });

      document.getElementById('btn-zoomin').addEventListener('click', () => {
        svg.transition().duration(300).call(zoom.scaleBy, 1.4);
      });

      document.getElementById('btn-zoomout').addEventListener('click', () => {
        svg.transition().duration(300).call(zoom.scaleBy, 0.7);
      });

      // ====== Info Panel ======
      function showInfoPanel(d) {
        currentSelected = d;
        const panel = document.getElementById('info-panel');
        panel.style.display = 'block';
        document.getElementById('info-name').textContent = d.data.name || '';
        document.getElementById('info-gen').textContent = d.data.generation || '';

        const dc = d.data.dc !== undefined ? d.data.dc : countDescendants(d.data);
        document.getElementById('info-descendants').textContent = `Ê≠§‰∫∫‰ª•‰∏ãÊî∂ÂΩï ${dc} ‰∫∫`;

        // Load saved notes, fall back to data.note (from Feishu), then to empty
        const savedNote = localStorage.getItem('ft_note_' + (d.data.id || d.data.name)) || '';
        const dataNote = d.data.note || '';
        const displayNote = savedNote || dataNote;
        document.getElementById('info-desc').textContent = displayNote || 'ÊöÇÊó†Â§áÊ≥®‰ø°ÊÅØ';
        document.getElementById('info-textarea').value = displayNote;
        document.getElementById('info-textarea').style.display = 'none';
        document.getElementById('info-save-btn').style.display = 'none';
      }

      function countDescendants(data) {
        if (!data._children_all) return 0;
        let count = data._children_all.length;
        data._children_all.forEach(c => { count += countDescendants(c); });
        return count;
      }

      document.getElementById('info-close').addEventListener('click', () => {
        document.getElementById('info-panel').style.display = 'none';
        currentSelected = null;
      });

      let editUnlocked = false;
      document.getElementById('info-edit-btn').addEventListener('click', () => {
        if (!editUnlocked) {
          const pwd = prompt('ËØ∑ËæìÂÖ•ÁºñËæëÂØÜÁ†ÅÔºö');
          if (pwd !== 'Lsb@1775') {
            alert('ÂØÜÁ†ÅÈîôËØØ');
            return;
          }
          editUnlocked = true;
        }
        const ta = document.getElementById('info-textarea');
        const sb = document.getElementById('info-save-btn');
        ta.style.display = ta.style.display === 'none' ? 'block' : 'none';
        sb.style.display = sb.style.display === 'none' ? 'block' : 'none';
      });

      document.getElementById('info-save-btn').addEventListener('click', () => {
        if (!currentSelected) return;
        const text = document.getElementById('info-textarea').value;
        const personName = currentSelected.data.name || 'Êú™Áü•';
        const personId = currentSelected.data.id || currentSelected.data.name;
        localStorage.setItem('ft_note_' + personId, text);
        addEditLog(personName, personId, text);
        document.getElementById('info-desc').textContent = text || 'ÊöÇÊó†Â§áÊ≥®‰ø°ÊÅØ';
        document.getElementById('info-textarea').style.display = 'none';
        document.getElementById('info-save-btn').style.display = 'none';
      });

      // ====== Search ======
      const searchInput = document.getElementById('search-input');
      const searchResults = document.getElementById('search-results');

      searchInput.addEventListener('input', () => {
        const q = searchInput.value.trim();
        if (!q) {
          searchResults.style.display = 'none';
          clearSearchHighlight();
          return;
        }
        const results = [];
        function searchTree(data) {
          if (data.name && data.name.includes(q)) {
            results.push(data);
          }
          if (data._children_all) data._children_all.forEach(searchTree);
        }
        searchTree(DATA);

        if (results.length === 0) {
          searchResults.innerHTML = '<div class="search-item" style="color:#606060">Êó†ÁªìÊûú</div>';
          searchResults.style.display = 'block';
          return;
        }

        searchResults.innerHTML = results.slice(0, 30).map(r =>
          `<div class="search-item" data-id="${r.id || ''}" data-name="${r.name}">` +
          `${r.name}<span class="gen">${r.generation || ''}</span></div>`
        ).join('');
        searchResults.style.display = 'block';

        searchResults.querySelectorAll('.search-item').forEach(item => {
          item.addEventListener('click', () => {
            const id = item.dataset.id;
            const name = item.dataset.name;
            navigateToNode(id, name);
            searchResults.style.display = 'none';
          });
        });
      });

      function navigateToNode(id, name) {
        // Expand the path from root to this node
        function findPath(data, targetId, targetName, path) {
          if ((data.id && data.id === targetId) || data.name === targetName) {
            path.push(data);
            return true;
          }
          if (data._children_all) {
            for (const child of data._children_all) {
              path.push(data);
              if (findPath(child, targetId, targetName, path)) return true;
              path.pop();
            }
          }
          return false;
        }

        const path = [];
        findPath(DATA, id, name, path);

        // Expand each node in path
        path.forEach(p => {
          if (p._children_all) {
            p._children_visible = p._children_all;
            p._expanded = true;
          }
        });

        // Set highlight
        searchHighlighted = id || name;

        const hierarchy = render(null);
        const target = findNodeInHierarchy(hierarchy, id || name);
        if (target) {
          centerOnNode(target._x, target._y, 1);
          // Show info
          showInfoPanel(target);
        }
      }

      function clearSearchHighlight() {
        searchHighlighted = null;
        render(null);
      }

      // Click outside to close search
      document.addEventListener('click', (e) => {
        if (!e.target.closest('#search-wrap')) {
          searchResults.style.display = 'none';
        }
      });

      // ====== Minimap ======
      const minimapCanvas = document.getElementById('minimap-canvas');
      const minimapCtx = minimapCanvas.getContext('2d');
      const minimapViewport = document.getElementById('minimap-viewport');
      const minimapContainer = document.getElementById('minimap-container');

      function updateMinimap() {
        const hierarchy = computeLayout();
        const nodes = hierarchy.descendants();
        if (nodes.length === 0) return;

        const cw = minimapContainer.clientWidth;
        const ch = minimapContainer.clientHeight;
        minimapCanvas.width = cw;
        minimapCanvas.height = ch;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        nodes.forEach(n => {
          if (n._x < minX) minX = n._x;
          if (n._x > maxX) maxX = n._x;
          if (n._y < minY) minY = n._y;
          if (n._y > maxY) maxY = n._y;
        });

        const pad = 20;
        const treeW = Math.max(maxX - minX, 1) + pad * 2;
        const treeH = Math.max(maxY - minY, 1) + pad * 2;
        const scaleX = cw / treeW;
        const scaleY = ch / treeH;
        const s = Math.min(scaleX, scaleY);

        minimapCtx.clearRect(0, 0, cw, ch);
        minimapCtx.fillStyle = 'rgba(212,175,55,0.3)';

        nodes.forEach(n => {
          const x = (n._x - minX + pad) * s;
          const y = (n._y - minY + pad) * s;
          minimapCtx.fillRect(x - 1, y - 1, 2, 2);
        });

        // Viewport rectangle
        const transform = d3.zoomTransform(svg.node());
        const viewLeft = -transform.x / transform.k;
        const viewTop = -transform.y / transform.k;
        const viewW = width / transform.k;
        const viewH = height / transform.k;

        const vx = (viewLeft - minX + pad) * s;
        const vy = (viewTop - minY + pad) * s;
        const vw = viewW * s;
        const vh = viewH * s;

        minimapViewport.style.left = Math.max(0, vx) + 'px';
        minimapViewport.style.top = Math.max(0, vy) + 'px';
        minimapViewport.style.width = Math.min(vw, cw) + 'px';
        minimapViewport.style.height = Math.min(vh, ch) + 'px';

        // Store for drag
        minimapContainer._treeRange = { minX: minX - pad, minY: minY - pad, treeW, treeH, scale: s };
      }

      // Minimap drag
      let minimapDragging = false;
      minimapContainer.addEventListener('mousedown', (e) => {
        minimapDragging = true;
        minimapJumpTo(e);
      });
      document.addEventListener('mousemove', (e) => {
        if (minimapDragging) minimapJumpTo(e);
      });
      document.addEventListener('mouseup', () => { minimapDragging = false; });

      function minimapJumpTo(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const range = minimapContainer._treeRange;
        if (!range) return;

        const treeX = mx / range.scale + range.minX;
        const treeY = my / range.scale + range.minY;

        const transform = d3.zoomTransform(svg.node());
        const tx = width / 2 - treeX * transform.k;
        const ty = height / 2 - treeY * transform.k;
        svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(transform.k));
      }

      // ====== Node Hover Tooltip ======
      let tooltipNode = null;
      let tooltipTimer = null;
      let tooltipShowTimer = null;
      let nodeEditUnlocked = false;
      const tooltip = document.getElementById('node-tooltip');

      function showNodeTooltip(event, d, el) {
        clearTimeout(tooltipTimer);
        clearTimeout(tooltipShowTimer);
        // Delay 3 seconds before showing
        tooltipShowTimer = setTimeout(() => {
          tooltipNode = d;
          const svgEl = svg.node();
          const pt = svgEl.createSVGPoint();
          pt.x = d._x;
          pt.y = d._y;
          const ctm = g.node().getScreenCTM();
          const screenPt = pt.matrixTransform(ctm);
          tooltip.style.display = 'block';
          tooltip.style.left = (screenPt.x + 15) + 'px';
          tooltip.style.top = (screenPt.y - 30) + 'px';
        }, 3000);
      }

      function hideNodeTooltipDelay() {
        clearTimeout(tooltipShowTimer);
        tooltipTimer = setTimeout(() => {
          tooltip.style.display = 'none';
          tooltipNode = null;
        }, 300);
      }

      // Keep tooltip visible when hovering over it
      tooltip.addEventListener('mouseenter', () => clearTimeout(tooltipTimer));
      tooltip.addEventListener('mouseleave', () => hideNodeTooltipDelay());

      function checkNodeEditPwd() {
        if (nodeEditUnlocked) return true;
        const pwd = prompt('ËØ∑ËæìÂÖ•ËäÇÁÇπÁºñËæëÂØÜÁ†ÅÔºö');
        if (pwd === 'Lsb@1775') {
          nodeEditUnlocked = true;
          return true;
        }
        alert('ÂØÜÁ†ÅÈîôËØØ');
        return false;
      }

      // ====== Load / Save Tree Modifications ======
      function getTreeMods() {
        try { return JSON.parse(localStorage.getItem('ft_tree_mods') || '{"added":[],"deleted":[]}'); }
        catch (e) { return { added: [], deleted: [] }; }
      }
      function saveTreeMods(mods) {
        localStorage.setItem('ft_tree_mods', JSON.stringify(mods));
      }
      function applyTreeMods() {
        const mods = getTreeMods();
        // Apply deletions
        mods.deleted.forEach(del => {
          const parent = findDataById(DATA, del.parentId);
          if (parent && parent._children_all) {
            parent._children_all = parent._children_all.filter(c => c.id !== del.nodeId);
            if (parent._children_all.length === 0) parent._children_all = null;
            if (parent._children_visible) {
              parent._children_visible = parent._children_all;
            }
          }
        });
        // Apply additions
        mods.added.forEach(add => {
          const parent = findDataById(DATA, add.parentId);
          if (parent) {
            // Check if already added (avoid duplicates on reload)
            const existing = parent._children_all && parent._children_all.find(c => c.id === add.node.id);
            if (!existing) {
              if (!parent._children_all) parent._children_all = [];
              const newNode = {
                name: add.node.name,
                id: add.node.id,
                generation: add.node.generation || '',
                note: add.node.note || '',
                children: [],
                _children_all: null,
                _children_visible: null,
                _expanded: false,
                dc: 0,
                depth: (parent.depth || 0) + 1
              };
              parent._children_all.push(newNode);
              if (parent._expanded) {
                parent._children_visible = parent._children_all;
              }
            }
          }
        });
      }

      function findDataById(data, id) {
        if (data.id === id) return data;
        const children = data._children_all || data.children || [];
        for (const c of children) {
          const found = findDataById(c, id);
          if (found) return found;
        }
        return null;
      }

      function findParentData(root, targetId) {
        const children = root._children_all || root.children || [];
        for (const c of children) {
          if (c.id === targetId) return root;
          const found = findParentData(c, targetId);
          if (found) return found;
        }
        return null;
      }

      // Apply saved mods on load
      applyTreeMods();

      // ====== Add Node ======
      document.getElementById('tt-add').addEventListener('click', () => {
        if (!checkNodeEditPwd()) return;
        if (!tooltipNode) return;
        tooltip.style.display = 'none';
        const parentData = tooltipNode.data;
        document.getElementById('add-dialog-title').textContent = '‰∏∫„Äå' + (parentData.name || '') + '„ÄçÊ∑ªÂä†Â≠êËäÇÁÇπ';
        document.getElementById('add-name').value = '';
        document.getElementById('add-gen').value = '';
        document.getElementById('add-note').value = '';
        const overlay = document.getElementById('add-node-overlay');
        overlay.style.display = 'flex';
        overlay._parentData = parentData;
        setTimeout(() => document.getElementById('add-name').focus(), 100);
      });

      document.getElementById('add-confirm').addEventListener('click', () => {
        const overlay = document.getElementById('add-node-overlay');
        const parentData = overlay._parentData;
        if (!parentData) return;
        const name = document.getElementById('add-name').value.trim();
        if (!name) { alert('ËØ∑ËæìÂÖ•ÂßìÂêç'); return; }
        const gen = document.getElementById('add-gen').value.trim();
        const note = document.getElementById('add-note').value.trim();
        const newId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
        const newNode = {
          name: name,
          id: newId,
          generation: gen,
          note: note,
          children: [],
          _children_all: null,
          _children_visible: null,
          _expanded: false,
          dc: 0,
          depth: (parentData.depth || 0) + 1
        };
        if (!parentData._children_all) parentData._children_all = [];
        parentData._children_all.push(newNode);
        parentData._children_visible = parentData._children_all;
        parentData._expanded = true;
        // Persist
        const mods = getTreeMods();
        mods.added.push({ parentId: parentData.id, node: { name, id: newId, generation: gen, note: note } });
        saveTreeMods(mods);
        // Log
        addEditLog(parentData.name + ' ‚Üí Ê∑ªÂä†Â≠êËäÇÁÇπ', parentData.id, 'Êñ∞Â¢ûÔºö' + name + (gen ? 'Ôºà' + gen + 'Ôºâ' : ''));
        // Re-render
        render(null);
        overlay.style.display = 'none';
        // Update stats
        updateStats();
      });

      document.getElementById('add-cancel').addEventListener('click', () => {
        document.getElementById('add-node-overlay').style.display = 'none';
      });

      document.getElementById('add-node-overlay').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) e.currentTarget.style.display = 'none';
      });

      // ====== Delete Node ======
      document.getElementById('tt-delete').addEventListener('click', () => {
        if (!checkNodeEditPwd()) return;
        if (!tooltipNode) return;
        tooltip.style.display = 'none';
        const nodeData = tooltipNode.data;
        if (nodeData === DATA) { alert('‰∏çËÉΩÂà†Èô§Ê†πËäÇÁÇπ'); return; }
        const childCount = nodeData._children_all ? nodeData._children_all.length : 0;
        const msg = childCount > 0
          ? 'Á°ÆÂÆöË¶ÅÂà†Èô§„Äå' + nodeData.name + '„ÄçÂèäÂÖ∂ ' + childCount + ' ‰∏™Â≠êËäÇÁÇπÂêóÔºü\n\nÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ'
          : 'Á°ÆÂÆöË¶ÅÂà†Èô§„Äå' + nodeData.name + '„ÄçÂêóÔºü\n\nÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ';
        if (!confirm(msg)) return;
        // Find parent and remove
        const parent = findParentData(DATA, nodeData.id);
        if (parent && parent._children_all) {
          parent._children_all = parent._children_all.filter(c => c.id !== nodeData.id);
          if (parent._children_all.length === 0) {
            parent._children_all = null;
            parent._children_visible = null;
            parent._expanded = false;
          } else if (parent._expanded) {
            parent._children_visible = parent._children_all;
          }
        }
        // Persist
        const mods = getTreeMods();
        mods.deleted.push({ parentId: parent ? parent.id : null, nodeId: nodeData.id, nodeName: nodeData.name });
        saveTreeMods(mods);
        // Log
        addEditLog('Âà†Èô§ËäÇÁÇπ', nodeData.id, 'Âà†Èô§Ôºö' + nodeData.name + (nodeData.generation ? 'Ôºà' + nodeData.generation + 'Ôºâ' : ''));
        // Re-render
        render(null);
        document.getElementById('info-panel').style.display = 'none';
        updateStats();
      });

      // Update stats display
      function updateStats() {
        const allNodes = [];
        const genSet = new Set();
        function walk(n) {
          allNodes.push(n);
          if (n.generation) genSet.add(n.generation);
          if (n._children_all) n._children_all.forEach(walk);
        }
        walk(DATA);
        document.getElementById('stats-line').textContent =
          'ÂÖ± ' + allNodes.length + ' ‰∫∫ ¬∑ ' + genSet.size + ' ‰ª£';
      }

      // ====== Initial Render ======
      // Expand root by default
      DATA._children_visible = DATA._children_all;
      DATA._expanded = true;
      render(null);
      setTimeout(fitAll, 600);
    }
  </script>
</body>

</html>